#php5.3

文件：zend_gc.h zend_gc.c

PHP变量存储在一个zval容器里面的，包括：
1.变量类型 2. 变量值 3. is_ref 代表是否有地址引用 4. refcount 指向该值的变量数量

基本算法：
  1. 如果发现一个zval容器中的refcount在增加，说明不是垃圾
  2. 如果发现一个zval容器中的refcount在减少，如果减到了0，直接当做垃圾回收
  3. 如果发现一个zval容器中的refcount在减少，并没有减到0，PHP会把该值放到缓冲区，当做有可能是垃圾的怀疑对象
  4. 当缓冲区达到临界值，PHP会自动调用一个方法取遍历每一个值，如果发现是垃圾就清理

如果变量赋值给另外一个变量，unset只是销毁了变量，同时refcount值减一，并没有销毁对应的内存。当指向变量的所有引用 ，都被销毁时候，refcount=0的时候 才会真正释放内存

#php5php7 垃圾回收机制的区别

- 对于复杂数据类型，引用计数算法不一样
- *zval 需要的内存不再是单独从堆上分配，不再自己存储引用计数。复杂数据类型（比如字符串、数组和对象）的引用计数由其自身来存储。这种实现方式有以下好处：
	- 简单数据类型不需要单独分配内存，也不需要计数；
	- 不会再有两次计数的情况。在对象中，只有对象自身存储的计数是有效的；
	- 由于现在计数由数值自身存储，所以也就可以和非 zval 结构的数据共享，比如 zval 和 hashtable key 之间；

#回收

如果一个引用计数增加，它将继续被使用，当然就不再在垃圾中。如果引用计数减少到零，所在变量容器将被清除(free)。就是说，仅仅在引用计数减少到非零值时，才会产生垃圾周期(garbage cycle)。其次，在一个垃圾周期中，通过检查引用计数是否减1，并且检查哪些变量容器的引用次数是零，来发现哪部分是垃圾。

文件：zend.enable_gc 

根缓冲区满了时，对缓冲区内部所有不同的变量容器执行垃圾回收操作

#php7 zval结构体
- Zvals不再单独分配，所以这节省了16个字节的内存分配冗余。
- Buckets也不用再单独分配，所以又节省了16个字节的内存分配冗余。
- 对于简单类型的值，zval本身就少了16个字节。
- 保持数组顺序不再需要16个字节用于维持双向链表的链接指针，而且这个顺序是隐式的。
- 冲突处理链表现在是单链表，这又节省了8个字节。更进一步来看，现在用的是一个索引列表，并且每个索引是嵌入到zval中的，所以这又节省了8个字节。
- zval是嵌入到bucket中的，没必要再保存一个指向它的指针。如果分析老版本的实现细节的话，我们实际上节省了2个指针，这就又是16个字节了。
- 键的长度不用再保存在bucket中，又是8个字节。不过，如果键是一个字符串，而不是一个整数的话，它的长度还是需要保存在zend_string结构体中。这种情况下，对内存的影响不可能精确估算，因为zend_string结构体是共享的，这意味着之前的hashtable需要拷贝字符串，如果这个字符串不是interned的话（这一条没怎么看清楚）。
- 包含冲突列表头部的数组现在是基于索引的，这样每个元素又节省了4个字节。对于packed数组，这个数组根本就不需要，又节省了4个字节。