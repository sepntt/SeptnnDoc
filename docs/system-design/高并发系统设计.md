#高并发系统设计(未完成)

##预算
  - 
  - 

##当前服务状况
  - 自有服务器 
  - 云服务器

##业务分析
 - 确定可能会有并发的请求是哪些：表单提交，分析当前页面总共有多少请求，多少静态多少动态。
    - 动静分离，cdn或者nginx静态化
 - 分析动态请求是cpu密集型，还是io密集型
 - 预估可能会有的并发量：2000
    - 


##计算硬件支持
  - 需求：多少并发，多少uv，多少在线活跃：500并发，20w用户在线，2000活跃。
  - 确定可能会有并发的请求：表单提交。
  - 基础测试，并发请求响应时间：200ms。
  - 计算1秒处理请求响应的数量=1000/200=5个
  - 基础测试，ab单机处理多少并发
    - 达到瓶颈后，分析瓶颈，优化单机
      - cpu密集型
        - 增加cpu资源，减少进程数=cpu核数
      - io密集型
        - 增加进程数
      - nginx
        - 进程数、文件描述符、io多路复用模型、连接数、超时时间
      - php
        - 静态php进程数、opcache开启、慢日志开启
      - mysql
        - 跳过nds解析、索引缓冲区、连接数、慢日志开启
      - linux
        - ulimit 当前用户进程的软硬配置 1048576=1024*1024 云主机一般65535
        - file-max 所有进程最多同时打开的文件句柄数 1048576 
        - 修改配置增加端口，还可以增加虚拟ip扩展端口数量
        - 
        - ipv4/tcp 优化 握手失败重复多少次，连接超时时间等
    - 内存优化
      - nginx 子进程10m
      - php-cgi 子进程20-30m
    - cpu优化
    - 磁盘
      - raid5磁盘阵列
  - 带宽计算，页面大小20k*并发500=9M，保证带宽够大

##dns轮循

##cnd缓存，防盗链
  - 防盗链
    - referer、登录信息、链接token、post+token

##负载
  - nginx服务器（单点？主主，主从）
    - 反向代理 upstream的模块proxy，一种负载的传输模式
      - 负载策略
        - 轮循 默认方式，轮循访问负载机
        - ip_hash 访问者iphash后，访问对应负载机
        - url_hash 访问urlhash后，访问对应负载机
        - weight 权重高，访问对应负载机
      - 检查负载机的存活状态。宕机，加上down配置，重启nginx；存活，去掉down配置，重启nginx
        - 脚本方式
        - 插件方式
    - ssl单点
    - 压缩、缓存
      - 静态文件，静态页面，直接缓存
  - 保持负载会话
    - redis

##应用服务器，微服务
  - nginx缓存，压缩
  - php-cgi
  - 最终一致性
    - redis锁
    - mysql锁

##缓存
  - memcache
  - redis
    - RDB save直接从内存中快照数据写入到二进制文件，bgsave fork一个子进程，讲数据写入临时文件，然后替换主进程使用的文件。命令备份
    - AOF 把每一个命令通过write函数追加到文件。动态写入1s
    - 缓存尽量使用脚本生成，不要实时生成

##队列
  - redis
    - lpush入队，rpop出队（非堵塞）
    - publish 发布 subscribe 订阅
  - 

##数据库
  - mysql
    - 主从库
      -  
    - 读写分离
    - 分布式
    - 分库分表
      - 业务分库
      - 冷热分表
    - 性能优化
    - 查询缓存
  - nosql
    - redis

##故障处理，风险处理
  - 负载故障
    - dns轮循
  - 单机故障
    - down单机
  - 服务故障
    - 
  - 数据库故障
    - 主主切换
    - 主从切换


##用户体验优化
  - js排队
  - 增加业务操作步骤
  - 禁止重复请求

##cron机
  - 两台cron机
   - 同时跑两个服务
     - 统计数据，可以统计两份，加版本号，查询，使用最新版本号
     - 业务逻辑，利用锁来只执行一次。
       - 悲观锁：加锁串行
       - 乐观锁：加version，先+1下次操作，比较是否+1